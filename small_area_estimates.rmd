---
title       : BRFSS Small Area Estimates
subtitle    : 
author      : Morgan Robinson 
job         : Data Analyst, PolicyMap
logo        : 
output      : html_document # {word_document}
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
widgets     : [mathjax]            # {mathjax, quiz, bootstrap}
mode        : draft # {standalone, selfcontained}
---
  

This document contains the methodology and R code necessary to process the small area estimates for Health Status in 2013. 

Would you say that in general your health is: 
  * Excellent, Very good: GEN_VGEXCL

## Load required libraries/connections
```{r loadlibraries, warning=FALSE, message=FALSE}
setwd("C:/Users/robinsonm/Documents/BRFSS-small-area-estimates")
library("RODBC")
library("ggplot2")
library("arm")

```

to do: load data, sample, then export to csv; 
save csv in github assets; 
comment out and remove actual paths.



1. BRFSS data structure
  a. predictor and response variables
2. ACS data structure
3. Exploratory Analysis and modeling
4. Predictive Results
5. Aggregating results (counties)
6. Map results


## Load the data
SQL connection reads the following data tables:
* Full record set of survey data, coded according to BRFSS 2013 manual {link here}
* State-level survey data, weighted with provided values
* Shell for prediction: a matrix of population of state/metro status/race/age/income classifications, based on 2009 - 2013 ACS and 2009 metropolitan classification (principal city/outlying county/rural)

```{r demo2013, cache=TRUE}
# rm(con)
# rm(data)
# rm(statedata)
# rm(geo_shell)
# 
# con <- odbcDriverConnect('driver={SQL Server};server=gis;database=CDC_BRFSS_PolicyMap;trusted_connection=true')
# geo_shell <- sqlQuery(
#   con, paste('SELECT * FROM dbo.geo_shell') , errors = TRUE) 
# 
# data <- sqlQuery(con, paste('select * from dbo.indicators_2013_cats_for_mrp'), errors = TRUE, max = 0)
# 
# statedata <- sqlQuery(con, paste('select * from dbo.inds_by_state_2013'), errors = TRUE)
# 
# data$FIPS <- factor(formatC(data$FIPS, width=2, flag="0"))
# statedata$FIPS <- formatC(statedata$FIPS, width=2, flag="0")
# geo_shell$FIPS <- factor(formatC(geo_shell$FIPS, width=2, flag="0"))
# 
# gh_rdata <- data[sample(1:nrow(data), size=5000, replace=F, prob = as.integer(data$LLCPWT)), ]

data <- read.table("gh_rdata.txt", header=TRUE, quote="\"", sep=",", dec = ".", stringsAsFactors=T) #saved input table


#geo_shell <- make .txt for some states

```

##Analyze the state and record level data
Good visualizations for this:
frequency


```{r matrix by state}
#statedata <- # make .txt

stcols <- c("MSCODE", "AVG_AGE_G", "AVG_INCOME_SCALE",  "AVG_HISPANC2", "AVG_WHITE", "AVG_BLACK", "AVG_OTHER",  "AVG_MULTI", "AVG_GENHLTH", "AVG_GEN_VGEXCL", "AVG_GEN_FRPOOR")
gh_statedata <-  statedata[,names(statedata) %in% stcols]

statecormat <- cor(gh_statedata, y = NULL, use = "everything")
corrplot(statecormat, details = TRUE, abs = TRUE)


```

##Merge the record-level survey with the state values
In this section we tag the record-level survey with the state indicators. This borrows strength from the weighted state data. We use the state FIPS code to join the data and create new fields in the record-level dataset.
``` {r datamerge, tidy=TRUE}

data$ST_MSSTATUS <- statedata$MSCODE[data$FIPS]# wt. average metro code among tracts in state
data$ST_AVG_AGE <- statedata$AVG_AGE_G[data$FIPS]# wt. average age group among tracts in state
data$ST_AVG_INC <- statedata$AVG_INCOME_SCALE[data$FIPS]# wt. average age group among tracts in state
data$ST_PCT_HISP <- statedata$AVG_HISPANC2[data$FIPS]# wt. pct of survey respondents in state who are hispanic
data$ST_PCT_BLK <- statedata$AVG_BLACK[data$FIPS]# wt. pct of survey respondents in state who are black
data$ST_PCT_WHITE <- statedata$AVG_WHITE[data$FIPS]  
data$ST_PCT_OTHER <- statedata$AVG_OTHER[data$FIPS]
data$ST_PCT_MULTI <- statedata$AVG_MULTI[data$FIPS] 
data$ST_GENHLTH <- statedata$AVG_GENHLTH[data$FIPS]# wt. average general health scale
data$ST_GEN_VGEXCL <- statedata$AVG_GEN_VGEXCL[data$FIPS]
data$ST_GEN_FRPOOR <- statedata$AVG_GEN_FRPOOR[data$FIPS]

```

##Prep the survey data for modeling
We take a robust sample of the survey data - due to memory/processing constraints, a full analysis is not possible. 40k records represents roughly 750 records per state, and should cover a meaningful number of the 640 combinations of race/age/income/metro status across all states. 

Survey weights are used in this sample to avoid bias.

##Isolate predicted and predictor variables
Select the response variable to predict, and all possible predictors. Use complete.cases to exclude all NA values from the sample.
``` {r variable selection}
ghcols <- c("STATE", "LLCPWT", "MSLABEL", "MSLABEL", "INCOME", "INCOMELABEL", "AGE_GLABEL", "AGE_G", "RACELABEL", "GEN_VGEXCL", "ST_GEN_VGEXCL")
gh_rdata <-  datareduce[,names(datareduce) %in% ghcols]

gh_rdata <- gh_rdata[complete.cases(gh_rdata), ]
gh_rdata$INCOMELABEL <- relevel(gh_rdata$INCOMELABEL, "I8")
gh_rdata$RACELABEL <- relevel(gh_rdata$RACELABEL, "RWH")

write.table(cbind(gh_rdata, deparse.level = 1),
                  "gh_rdata.txt",quote=TRUE,sep=",",col.names=TRUE,row.names=FALSE, na = "", append=FALSE) #sample data output table


```

##Exploratory modeling
Use a generalized linear model to identify variables for modeling

```{r glm, eval=FALSE}
```


``` {r linear model, cache=TRUE}

# ggplot(gh_rdata, aes(x=GENHLTH, y=AGE_G | RACELABEL + INCOMELABEL, size=population)


gh_glm <- glmer(GEN_VGEXCL ~  RACELABEL + INCOMELABEL + AGE_GLABEL + ST_GEN_VGEXCL + (1| MSLABEL:RACELABEL), family = "binomial", data = gh_rdata)

predictsample <- data[sample(1:nrow(data), size=5000, replace=T, prob = as.integer(data$LLCPWT)), ]

predictsample$PR_GEN_VGEXCL1 <- predict(
  gh_glm, type = "response", newdata = predictsample, allow.new.levels = TRUE)
summary(predictsample$PR_GEN_VGEXCL1)
summary(predictsample$GEN_VGEXCL)
summary(predictsample$ST_GEN_VGEXCL)

xyplot(PR_GEN_VGEXCL1~ AGE_G | STATE, data = predictsample)


```


``` {r predict gen. hlth excellent small areas, echo=FALSE}
geo_shell$MSLABEL <- formatC(geo_shell$MSCODE, width = "1")
geo_shell$MSLABEL[geo_shell$MSLABEL == "1"] <- "RA"
geo_shell$MSLABEL[geo_shell$MSLABEL == "2"] <- "SC"
geo_shell$MSLABEL[geo_shell$MSLABEL == "3"] <- "CC"
geo_shell$MSLABEL[geo_shell$MSLABEL == "4"] <- "IC"

geo_shell$MSLABEL <- factor(geo_shell$MSLABEL)
geo_shell$MSCODE <- factor(geo_shell$MSCODE)

geo_shell$AGE[geo_shell$AGE == "1"] <- "A1"
geo_shell$AGE[geo_shell$AGE == "2"] <- "A2"
geo_shell$AGE[geo_shell$AGE == "3"] <- "A3"
geo_shell$AGE[geo_shell$AGE == "4"] <- "A4"
geo_shell$AGE_GLABEL <- factor(geo_shell$AGE)
geo_shell$RACELABEL <- factor(geo_shell$RACE)

geo_shell$INCOME[geo_shell$INCOME == "1"] <- "I1"
geo_shell$INCOME[geo_shell$INCOME == "2"] <- "I2"
geo_shell$INCOME[geo_shell$INCOME == "3"] <- "I3"
geo_shell$INCOME[geo_shell$INCOME == "4"] <- "I4"
geo_shell$INCOME[geo_shell$INCOME == "5"] <- "I5"
geo_shell$INCOME[geo_shell$INCOME == "6"] <- "I6"
geo_shell$INCOME[geo_shell$INCOME == "7"] <- "I7"
geo_shell$INCOME[geo_shell$INCOME == "8"] <- "I8"
geo_shell$INCOMELABEL <- factor(geo_shell$INCOME)
geo_shell$STATE <- factor(statedata$STATE[geo_shell$FIPS])


```

```{r}
geo_shell$ST_GEN_VGEXCL <- statedata$AVG_GEN_VGEXCL[geo_shell$FIPS]
#add predicted values:


geo_shell$PR_GEN_VGEXCL <- predict(
   gh_glm0, type = "response", newdata = geo_shell, allow.new.levels = TRUE)


#plot state results against predicted values
xyplot(geo_shell$PR_GEN_VGEXCL ~ geo_shell$ST_GEN_VGEXCL)
#bwplot by state

head(geo_shell)


```


``` {r map}

## county map with ggplot2

```
